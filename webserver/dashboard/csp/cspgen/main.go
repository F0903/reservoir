package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/net/html"
)

// ================================================================================
// Generates a Go source file containing the CSP header with computed script hashes
// ================================================================================

func sha256b64(b []byte) string {
	sum := sha256.Sum256(b)
	return "sha256-" + base64.StdEncoding.EncodeToString(sum[:])
}

func innerText(n *html.Node) string {
	var buf bytes.Buffer
	var rec func(*html.Node)
	rec = func(nd *html.Node) {
		for c := nd.FirstChild; c != nil; c = c.NextSibling {
			switch c.Type {
			case html.TextNode:
				buf.WriteString(c.Data) // already unescaped by tokenizer
			case html.ElementNode:
				rec(c)
			}
		}
	}
	rec(n)
	return buf.String()
}

func hasAttr(n *html.Node, name string) bool {
	for _, a := range n.Attr {
		if strings.EqualFold(a.Key, name) {
			return true
		}
	}
	return false
}

func walk(n *html.Node, visit func(*html.Node)) {
	var rec func(*html.Node)
	rec = func(nd *html.Node) {
		visit(nd)
		for c := nd.FirstChild; c != nil; c = c.NextSibling {
			rec(c)
		}
	}
	rec(n)
}

func makeHashes(blobs [][]byte) []string {
	seen := map[string]struct{}{}
	add := func(h string) { seen[h] = struct{}{} }

	for _, b := range blobs {
		raw := b
		lf := bytes.ReplaceAll(raw, []byte("\r\n"), []byte("\n"))
		rawTrim := bytes.TrimSpace(raw)
		lfTrim := bytes.TrimSpace(lf)

		rawH := sha256b64(raw)
		lfH := sha256b64(lf)
		rawTrimH := sha256b64(rawTrim)
		lfTrimH := sha256b64(lfTrim)

		add(rawH)
		add(lfH)
		add(rawTrimH)
		add(lfTrimH)
	}

	out := make([]string, 0, len(seen))
	for h := range seen {
		out = append(out, h)
	}
	return out
}

func buildCSPHeader(scriptHashes []string) string {
	var b bytes.Buffer
	b.WriteString("default-src 'self'; ")

	b.WriteString("script-src 'self'")
	for _, h := range scriptHashes {
		b.WriteString(" '")
		b.WriteString(h)
		b.WriteString("'")
	}
	b.WriteString("; ")

	// Required to use unsafe-inline here due to Svelte injecting styles dynamically.
	b.WriteString("style-src 'self' 'unsafe-inline'; ")
	b.WriteString("font-src 'self'; ")
	b.WriteString("worker-src 'self'; ")
	b.WriteString("img-src 'self' blob: data:; ")
	b.WriteString("connect-src 'self'; ")
	b.WriteString("object-src 'none'; ")
	b.WriteString("base-uri 'none'; ")
	b.WriteString("frame-ancestors 'none'")
	return b.String()
}

func main() {
	wd, err := os.Getwd()
	if err != nil {
		panic(fmt.Sprintf("Unable to get working directory: %v", err))
	}

	in := filepath.Clean(filepath.Join(wd, "..", "frontend", "build", "index.html"))
	out := filepath.Clean(filepath.Join(wd, "hashes_gen.go"))

	data, err := os.Open(in)
	if err != nil {
		panic(fmt.Sprintf("Unable to open input file: %v", err))
	}
	defer data.Close()

	root, err := html.Parse(data)
	if err != nil {
		panic(fmt.Sprintf("Unable to parse HTML: %v", err))
	}

	// Extract exact text of inline <script> (no src) and <style>
	var scriptBlobs [][]byte
	var styleBlobs [][]byte

	walk(root, func(n *html.Node) {
		if n.Type != html.ElementNode {
			return
		}
		switch n.Data { // lower-cased by the parser
		case "script":
			if hasAttr(n, "src") {
				return
			}
			txt := innerText(n) // text nodes under <script>; entities already unescaped
			if len(txt) > 0 {
				scriptBlobs = append(scriptBlobs, []byte(txt))
			}
		case "style":
			txt := innerText(n)
			if len(txt) > 0 {
				styleBlobs = append(styleBlobs, []byte(txt))
			}
		}
	})

	scriptHashes := makeHashes(scriptBlobs)
	header := buildCSPHeader(scriptHashes)
	src := generateGoFile(header, scriptHashes)

	err = os.WriteFile(out, []byte(src), 0644)
	if err != nil {
		panic(fmt.Sprintf("Unable to create output file: %v", err))
	}

	fmt.Fprintf(os.Stderr, "cspgen: wrote %s\n", out)
}

func generateGoFile(header string, scriptHashes []string) string {
	return fmt.Sprintf(`// Code generated by cspgen; DO NOT EDIT.
package csp

var ScriptHashes = %#v

// Header is the Content-Security-Policy header for the dashboard build.
var Header = %q
`, scriptHashes, header)
}
